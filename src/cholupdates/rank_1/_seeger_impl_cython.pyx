"""Cython implementation of the symmetric rank-1 up- and downdate algorithms from
sections 2 and 3 in [1]_.

References
----------
.. [1] M. Seeger, "Low Rank Updates for the Cholesky Decomposition", 2008.
"""

cimport libc.math

import numpy as np

cimport cython
cimport scipy.linalg.cython_blas


@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing
cpdef void update(
    double[:, :] L,
    double[::1] v,
) except *:
    """Cython implementation of the rank-1 update algorithm from section 2 in [1]_.

    Warning: The validity of the arguments will not be checked by this method, so
    passing invalid argument will result in undefined behavior.

    Parameters
    ----------
    L :
        The lower-triangular Cholesky factor of the matrix to be updated.
        Must have shape `(N, N)` and dtype `np.double`.
        Must not contain zeros on the diagonal.
        The entries in the strict upper triangular part of :code:`L` can contain
        arbitrary values, since the algorithm neither reads from nor writes to this part
        of the matrix.
        Will be overridden with the Cholesky factor of the matrix to be updated.
    v :
        The vector :math:`v` with shape :code:`(N, N)` and dtype :class:`numpy.double`
        defining the symmetric rank-1 update :math:`v v^T`.
        Will be reused as an internal memory buffer to store intermediate results, and
        thus modified.

    References
    ----------
    .. [1] M. Seeger, "Low Rank Updates for the Cholesky Decomposition", 2008.
    """

    cdef int N = L.shape[0]

    # Define pointers into the raw memory buffers
    cdef double* L_ptr = &L[0, 0]
    cdef double* v_ptr = &v[0]

    # Extract strides from memory layout. These are used for pointer arithmetic.
    cdef int L_row_stride
    cdef int L_col_stride

    if L.is_f_contig():
        L_row_stride = 1
        L_col_stride = N
    elif L.is_c_contig():
        L_row_stride = N
        L_col_stride = 1
    else:
        raise ValueError(
            "Unsupported memory layout. L should either be Fortran- or C-contiguous"
        )

    cdef int v_stride = 1

    # c and s will contain the cosine and sine terms that define the Givens rotations
    # in the loop
    cdef double c
    cdef double s

    # Loop variable
    cdef int k = 0

    # This must always be set to N - (k + 1)
    cdef int drot_n = N - 1

    while k < N - 1:
        # - L contains a lower-triangular matrix
        # - v contains a vector with zeros in its first k entries
        # - L_ptr points to the L[k, k]
        # - v_ptr points to the v[k]
        # - drot_n is set to N - (k + 1)

        # Generate Givens rotation which eliminates v[k] by rotating onto L[k, k] and
        # directly apply it only to these entries of (L|v)
        scipy.linalg.cython_blas.drotg(
            L_ptr,
            v_ptr,
            &c,
            &s
        )

        # Now the first k + 1 entries of v are zeros

        # Givens rotations generated by BLAS' `drotg` might rotate the diagonal entry to
        # a negative value. However, by convention, the diagonal entries of a Cholesky
        # factor are positive. As a remedy, we add another 180 degree rotation to the
        # Givens rotation matrix. This flips the sign of the diagonal entry while
        # ensuring that the resulting transformation is still a Givens rotation.
        if L_ptr[0] < 0.0:
            L_ptr[0] = -L_ptr[0]
            c = -c
            s = -s

        # Apply (modified) Givens rotation to the remaining entries in the k-th column
        # of L and the remaining entries in v

        # The first k entries in the k-th column of L are zero, since L is lower
        # triangular. Moreover, the first k entries of v are zero.
        # Since we already applied the Givens rotation to the k-th diagonal element of L
        # and the k-th element of v, it suffices to apply it to the slices
        # L[(k + 1):, k] and v[(k + 1):] here

        L_ptr += L_row_stride
        v_ptr += 1

        # L_ptr points to L[k + 1, k] and v_ptr points to v[k + 1]

        scipy.linalg.cython_blas.drot(
            # Apply to the last N - (k + 1) elements
            &drot_n,
            # The next two lines define the slice L[(k + 1):, k]
            L_ptr,
            &L_row_stride,
            # The next two lines define the slice v[(k + 1):]
            v_ptr,
            &v_stride,
            &c,
            &s
        )

        # Advance loop variable
        k = k + 1
        L_ptr += L_col_stride  # L_ptr must point to L[k, k]
        # v_ptr already points to v[k]
        drot_n -= 1  # drot_n must be set to N - (k + 1)

    # L_ptr points to L[-1, -1] and v_ptr points to v[-1]

    # Unroll the last iteration of the loop in order to avoid an if statement around the
    # drot call in the loop
    scipy.linalg.cython_blas.drotg(
        L_ptr,
        v_ptr,
        &c,
        &s
    )

    if L_ptr[0] < 0.0:
        L_ptr[0] = -L_ptr[0]


@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing
cpdef void downdate(
    double[:, :] L,
    double[::1] v,
) except *:
    cdef int N = L.shape[0]

    # Define pointers into the raw memory buffers
    cdef double* L_ptr = &L[0, 0]
    cdef double* v_ptr = &v[0]

    # Extract strides from memory layout. These are used for pointer arithmetic.
    cdef int L_row_stride
    cdef int L_col_stride

    if L.is_f_contig():
        L_row_stride = 1
        L_col_stride = N
    elif L.is_c_contig():
        L_row_stride = N
        L_col_stride = 1
    else:
        raise ValueError(
            "Unsupported memory layout. L should either be Fortran- or C-contiguous"
        )

    cdef int v_stride = 1

    # Solve triangular system L * p = v
    cdef char dtrsv_uplo
    cdef char dtrsv_trans

    if L.is_f_contig():
        dtrsv_uplo = b'L'
        dtrsv_trans = b'N'
    elif L.is_c_contig():
        dtrsv_uplo = b'U'
        dtrsv_trans = b'T'

    cdef char dtrsv_diag = b'N'

    scipy.linalg.cython_blas.dtrsv(
        &dtrsv_uplo,
        &dtrsv_trans,
        &dtrsv_diag,
        &N,
        L_ptr,
        &N,
        v_ptr,
        &v_stride,
    )

    # The memory buffer for v now contains p
    cdef double* p_ptr = v_ptr
    cdef int p_stride = v_stride

    # Compute rho = âˆš(1 - p^T p)
    cdef double p_norm_sq = scipy.linalg.cython_blas.ddot(
        &N,
        p_ptr,
        &p_stride,
        p_ptr,
        &p_stride
    )

    cdef double rho_sq = 1.0 - p_norm_sq

    if rho_sq <= 0.0:
        raise np.linalg.LinAlgError("The downdated matrix is not positive definite.")

    cdef double rho = libc.math.sqrt(rho_sq)

    # Stack p and rho into q = (p, rho)^T
    cdef double* q_ptr = p_ptr
    cdef int q_stride = p_stride

    cdef double q_np1 = rho

    # Temporary storage
    cdef double[::1] temp = np.zeros(N, dtype=np.double)

    cdef double* temp_ptr = &temp[0]
    cdef int temp_stride = 1

    # c and s will contain the cosine and sine terms that define the Givens rotations
    # in the loop
    cdef double c
    cdef double s

    cdef double m1 = -1.0

    # Initialize loop variables
    cdef int k = N - 1

    q_ptr += k * q_stride
    L_ptr += k * (L_row_stride + L_col_stride)
    temp_ptr += k * temp_stride

    cdef int drot_n = 1

    while k >= 0:
        scipy.linalg.cython_blas.drotg(&q_np1, q_ptr, &c, &s)

        if q_np1 < 0.0:
            q_np1 = -q_np1
            c = -c
            s = -s

        scipy.linalg.cython_blas.drot(
            &drot_n,
            temp_ptr,
            &temp_stride,
            L_ptr,
            &L_row_stride,
            &c,
            &s,
        )

        if L_ptr[0] < 0.0:
            scipy.linalg.cython_blas.dscal(
                &drot_n,
                &m1,
                L_ptr,
                &L_row_stride,
            )

        # Advance loop variables
        k -= 1

        q_ptr -= q_stride
        L_ptr -= L_row_stride + L_col_stride
        temp_ptr -= temp_stride

        drot_n += 1
